'use strict';

const Context = require('./context');
const async = require('async');
const Script = require('./script');
const utils = require('./utils');
const exec = require('./exec');
const coder = require('./coder');
const globals = require('./globals');

//
//
//
const cache = {}; // cache for previously compiled scripts
module.exports.inline = (context, filter, options, compile, next) => {
	if (next === undefined) {
		next = options;
		options = {}; // handle optional options
	}
// TODO test and describe use of namespace	
	const namespace = options.namespace || ''; // for separating competing closures
	const hash = (namespace.constructor === Array ? namespace.join('/') : namespace.toString()) + '/' + utils.hashString(utils.jsformat(filter));
	let found = cache[hash];
	(next => {
		if (found) return next(null, found);
		compile(filter, options, next)
	})((err, filter) => { if (err) return next(err);
		utils.execute(context, cache[hash] = filter, next);
	});
}

//
// compile multiple filters
// 
module.exports.compileMultiple = (filters, options, compile, next) => {
	if (next === undefined) {
		next = options;
		options = {}; // handle optional options
	}
	const newFilters = {};
	const modifiers = Object.assign({}, options.modifiers); 	// copy modifiers
	return async.forEachOfSeries(filters, (filter, key, next) => { next = utils.defer(next); // in series to ensure backward reference
		compile(filter, Object.assign({}, options, { key }), (err, filter) => { 
			if (err) return next(err);
			options.modifiers = Object.assign({}, modifiers);  	// restore modifiers
			newFilters[key] = filter;
			next();
		});
	}, err => next(err, newFilters));
};

//
// compile filters 
//
module.exports.compile = (filter, options, compileType, vX, next) => {
	if (next === undefined) {
		next = options;
		options = {}; // handle optional options
	}
	// options include: 
	// modifiers - to compile modified
	// key - 
	// inspect - to show compiled code
	// namespace - only handled in inline to differentiate multiple compilations of same code

	const key = (!('key' in options)) ? 'filter' : String(options.key);
	const context = new Context({
		source: { [key]: filter },
		key,
		scope: { 
			functions: [],
			modifiers: Object.assign({}, options.modifiers),
		}
	});
	const timestamp = Date.now();
	(next => {
		compileType(context, (err, script) => { if (err) return next(err); 
			let code;
			try {
				code = (new Script(
					...coder.compile(key, vX, timestamp, script)
		    	)).toString();
				utils.peep(code, options.inspect);
				code = eval(code)[key];
			}
			catch (err) {
				if (!options.inspect) utils.peep(code, true);
				return next(err);
			}
			next(null, code); 
		});
	})((err, filter) => { 
		if (err) {
			err.action = 'Compile';
			return next(err);
		}
		filter.functions = context.scope.functions;
		filter.timestamp = timestamp;
		filter.compiler = vX;
		next(null, filter);
	});
};

//
//
//
module.exports.compileString = (context, filter, compile, next) => { // next(err, script)
	const modifiers = context.scope.modifiers;

	// create key, mangling filter name with compiler options, to differentiate strings compiled under different options
	let key = filter + '{'; for (const mod of Object.keys(modifiers || {}).sort((a, b) => { return a.localeCompare(b); })) { if (mod[0] == '$') key += mod + ':' + modifiers[mod].toString(); } key += '}';

// HOW TO avoid outer string modifiers to hit inner strings possibly also modified, e.g. Type2{$optional:true} inadverdently leads to Shell2{$optional:true}
// we want to remove optional from modifiers when transition from Type2 to Shell2, right after Type2, before any possibly modification of Shell2

	async.waterfall([
		next => {
			if (utils.intrinsic.filter[key] === true || (utils.intrinsic.filter[key] !== undefined && utils.intrinsic.filter[key].timestamp > utils.intrinsic.timestamp)) return next(null);
	        
	        let spec;
            if (utils.staticFilters[filter] !== undefined)
                spec = utils.staticFilters[filter];
            else if (utils.systemFilters[filter] !== undefined)
                spec = utils.systemFilters[filter];
            else 
                return next(utils.ctx(context, new Error(`holds unknown filter references '(${filter})'`)));
            
            // stop any recursive compilation
            if (!(key in utils.intrinsic.filter)) utils.intrinsic.filter[key] = true;
            else utils.intrinsic.filter[key].timestamp = Date.now(); 
// TODO inspect: [].includes(filter) for debugging purpose
			compile(spec, Object.assign({}, { modifiers, inspect: [].includes(filter), key}), (err, compiled) => {
				utils.intrinsic.filter[key] = compiled;
				next(err);
            });
	    },
	    next => { 
    		const scriptKey = new Script(); // placeholder for substituting optional key filter
    		const script = new Script().link('key', scriptKey).push(
		    	...coder.sourceString(scriptKey, key)
    		);
    		next(null, script);
	    }
	], next);
};

//
// compile function (and null)
//
module.exports.compileFunction = (context, filter, next) => { // next(err, script)
	const script = new Script();
	async.waterfall([
		next => compileSource(context, script, next),
		(scriptMore, next) => compileMap(context, scriptMore, next),
		// compile function type, null means any type, thus no type check
		(scriptMore, next) => {
			if (context.scope.modifiers.$parallel)
				return next(utils.ctx(context, new Error(`cannot filter ${filter ? filter.name : 'null'} in parallel`)));
			if (filter !== null) scriptMore.push(
				...coder.functionType(filter)
			);
			next(null, scriptMore);
		},
		(scriptMore, next) => compileAssert(context, scriptMore, next),
		// compile assignment 
		(scriptMore, next) => {
			if (!context.scope.insideKey) scriptMore.push( // don't assign target when inside key filter
				...coder.functionAssign(context.scope.modifiers.$rename, context.scope.functions)
			);
			next(null, scriptMore);
		},
		(scriptMore, next) => compileConvert(context, scriptMore, filter === null ? null : Function, next),
		(scriptMore, next) => compileRemove(context, scriptMore, next),
	], err => { if (err && err !== true) return next(err);
		next(null, script);
	});
}
//
// compile, possibly create, existence of source, looking at $insert, $default, $map, and $optional
//
const compileSource = module.exports.compileSource = (context, script, next) => { // next(err, scriptMore)
	const modifiers = context.scope.modifiers; 

	// $insert and $default modifiers are mutually exclusive and collectively they are mutually exclusive with $optional === false (mandatory)
	if (modifiers) {
		const rid = ('$insert' in modifiers ? 1 : 0) + ('$default' in modifiers ? 1 : 0 ) + ('$optional' in modifiers ? 1 : 0 );
		if (rid > 1) return next(utils.ctx(context, new Error(`holds multiple of $insert, $default, or $optional modifiers`)));
	}
	const scriptKey = new Script(); // placeholder for substituting optional key filter
	const scriptMore = new Script();
	script.link('key', scriptKey).push(
		...coder.sourceKeep(scriptKey, scriptMore)
	);
	// if scope is set, assign to context, do not return 
	if (modifiers && '$scope' in modifiers)
		scriptMore.push(
			...coder.sourceScope(modifiers.$scope, context.scope.functions)
		);
	// if insert, do return
	if (modifiers && '$insert' in modifiers) {
		scriptMore.push(
			...coder.sourceInsert(modifiers.$insert, context.scope.functions)
		);
		return next(null, scriptMore);
	}
	// if default, do return
	if (modifiers && '$default' in modifiers) {
		scriptMore.push(
			...coder.sourceDefault(modifiers.$default, context.scope.functions)
		);
		return next(null, scriptMore);
	}
	if (!context.scope.insideKey) scriptMore.push(
		...coder.sourceOptional(modifiers.$optional || false, context.scope.functions)
	);
	next(null, scriptMore);
}

const compileMap = (context, scriptMore, next) => { // next(err)
	const modifiers = context.scope.modifiers; 
	if (modifiers && '$map' in modifiers) {
		scriptMore.push(
			...coder.map(modifiers.$map, context.scope.functions)
		);
	}
	return next(null, scriptMore);
}

//
//
//
const compileAssert = (context, scriptMore, next) => { // next(err, scriptNext)
	const modifiers = context.scope.modifiers;
	if (!modifiers) return next(null, script);
	if ('$message' in modifiers)
		scriptMore.push(
			...coder.message(modifiers.$message, context.scope.functions)
		);
	
	// TODO possible identify 'conflicting' modifiers (e.g. minlen and maxlen) and if not functional test if they conflict or not	
	
	[ '$length', '$minlen', '$maxlen', '$name', '$constructor', '$lt', '$lte', '$eq', '$ne', '$gte', '$gt', '$match', '$in', '$nin', '$inc', '$ninc' ].map(modifier => {
		if (modifier in modifiers)
			scriptMore.push(
				...coder.assert(modifiers, modifier, context.scope.functions)
			);
	});
	next(null, scriptMore);
}

const compileConvert = (context, scriptMore, type, next) => {
	const modifiers = context.scope.modifiers; 
	if (!modifiers) return next(null, script);
	if (('$toObject' in modifiers ? 1 : 0) + ('$toArray' in modifiers ? 1 : 0) > 1) return next(utils.ctx(context, new Error(`holds multiple of $toArray or $toObject`)));
	if ('$toObject' in modifiers) {
		if (type === Array || type === null) {
			scriptMore.push(
				...coder.convertToObject(modifiers.$toObject, context.scope.functions)
			);
		}
		else
			return next(utils.ctx(context, new Error(`cannot convert to Object if not Array`)));
	}
	if ('$toArray' in modifiers) {
		if (type === Object || type === null) {
			scriptMore.push(
					...coder.convertToArray(modifiers.$toArray, context.scope.functions)
				);
		}
		else
			return next(utils.ctx(context, new Error(`cannot convert to Array if not Object`)));
	}
	next(null, scriptMore);
}

const compileRemove = (context, scriptMore, next) => {
	const modifiers = context.scope.modifiers; 
	if ('$remove' in modifiers)
		scriptMore.push(
			...coder.targetRemove(modifiers.$remove, context.scope.functions)
		);
	next(null, scriptMore);
}

//
// compile object
//
module.exports.compileObject = (context, funcEntry, funcRest, next) => { // next(err, script)
	const modifiers = context.scope.modifiers; 
	const script = new Script();
	const managedKeys = {};

	async.waterfall([
		// compile source
		next => compileSource(context, script, next),
		// compile map
		(scriptMore, next) => compileMap(context, scriptMore, next),
		// compile object type
		(scriptMore, next) => {
			const scriptKeys = new Script().separator(',');
			async.forEachOfSeries(context.source[context.key], (entry, key, next) => { // next = utils.defer(next);	
				// identify and mark multiple keys, clean out any $
				const keys = key.split(/[\|\+]/).map(key => key.trim());
				
				const $ = keys.indexOf('$');
				if ($ > -1) {
					managedKeys['$'] = entry;
					keys.splice($, 1);
					key = keys.join('|');
				}
				// mark keys managed, error if duplicate keys
				for (let k = 0; k < keys.length; k++) {
					if (keys[k] in managedKeys) return next(utils.ctx(context, new Error(`.${keys[k]} is duplicated`))); 
					managedKeys[keys[k]] = entry;
				}
// TODO investigate above key management, is it necessary?
				if (key == '') return next();
// TODO what if any key is non-identifer, could we merge with 2 options below?
				funcEntry(context, key, (err, scriptEntry) => { if (err) return next(err);
					scriptKeys.push(new Script(
						...coder.objectKeys(keys, scriptEntry)
					));
					next();
				});
			}, err => next(err, scriptMore, scriptKeys));
		},
		// fetch rest script
		(scriptMore, scriptKeys, next) => '$' in managedKeys ? funcRest(context, (err, scriptRest) => next(err, scriptMore, scriptKeys, scriptRest)) : next(null, scriptMore, scriptKeys, null),
		// compile object type
		(scriptMore, scriptKeys, scriptRest, next) => {
			const scriptExcessive = new Script();
			scriptMore.push(
				...coder.objectWrapper(modifiers.$rename, context.scope.functions, modifiers.$parallel, scriptKeys, scriptExcessive)
			);
			scriptExcessive.push( 
				... (scriptRest ? coder.objectRest(scriptKeys, scriptRest) : coder.objectExcessive(scriptKeys))
			);
			next(null, scriptMore);
		},
		(scriptMore, next) => compileAssert(context, scriptMore, next),
		(scriptMore, next) => compileConvert(context, scriptMore, Object, next),
		(scriptMore, next) => compileRemove(context, scriptMore, next),
	], err => { if (err && err !== true) return next(err);
		next(null, script);
	});
};
//
// compile array
//
module.exports.compileArray = (context, funcEntry, next) => { // next(err, script)
	const modifiers = context.scope.modifiers; 
	const script = new Script();
	async.waterfall([
		next => compileSource(context, script, next),
		(scriptMore, next) => compileMap(context, scriptMore, next),
		// fetch entry script
		(scriptMore, next) => funcEntry(context, (err, scriptEntry) => next(err, scriptMore, scriptEntry)),
		// compile array type
		(scriptMore, scriptEntry, next) => {
			scriptMore.push(
				...coder.array(modifiers.$rename, context.scope.functions, modifiers.$parallel, scriptEntry)
			);
			next(null, scriptMore);
		},
		(scriptMore, next) => compileAssert(context, scriptMore, next),
		(scriptMore, next) => compileConvert(context, scriptMore, Array, next),
		(scriptMore, next) => compileRemove(context, scriptMore, next),
	], err => { if (err && err !== true) return next(err);
		next(null, script);
	});
}