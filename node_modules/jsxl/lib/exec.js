'use strict';
const async = require('async');
const Context = require('./context');
const utils = require('./utils');
const globals = require('./globals');

// TODO ensure all function calls have return types checked


// TODO fetch utils that are only used here... like nullify()
// Hmm no TODO could we omit exec.optional(context, false, next), all together when false (liek remove)

// TODO could remove avoid all the previous assignments, checks etc.

module.exports.type = (context, type, next) => {
	const value = context.source[context.key];
	if (utils.isType(value, type)) return next(null); 
	next(utils.ctx(context, new Error(`must be of type ${type.name} (not ${utils.typeName(value)})`)));
}

module.exports.typeName = (context, name, next) => {
	const value = context.source[context.key];
	if (utils.isTypeName(value, name)) return next(null); 
	next(utils.ctx(context, new Error(`must be of type ${name} (not ${utils.typeName(value)})`)));
}

module.exports.array = (context, handler, next) => { 
	const source = context.source[context.key];
	let target = context.target[context.rename];	
	
	// test source type
	if (!utils.likeArray(source)) return next(utils.ctx(context, new Error(`must be like type Array (not ${utils.typeName(source)})`)));
	
	// copy source and target
	const prevSource = source; // context.source[context.key];
	context.source[context.key] = [].concat(source);
	let targetCopy; 
	
	// provide target or test type of provided target
	if (target === undefined) target = context.target[context.rename] = []; 
	else if (!utils.likeArray(target)) return next(utils.ctx(context, new Error(`(target) must be like type Array (not ${utils.typeName(target)})`)));
	else targetCopy = [].concat(target);
	
	handler(err => {
		context.source[context.key] = prevSource; // reset source
		if (err) {
			// reset target
			if (targetCopy) target.splice(0, target.length, ...targetCopy);
			else context.target[context.rename] = undefined;
		}
		else {
			context.source[context.key] = target;
			context.target[context.rename] = context.target[context.rename].filter(() => true);
		}
		next(err);
	});
}

module.exports.arraySeries = (context, handler, next) => {
	async.timesSeries(context.source[context.key].length, (key, next) => handler(key, utils.defer(utils.nullifyTrue(next))), next);
}

module.exports.arrayParallel = (context, handler, next) => {
	async.times(context.source[context.key].length, (key, next) => handler(key, utils.defer(utils.nullifyTrue(next))), next);
}

module.exports.object = (context, handler, next) => {
	const source = context.source[context.key];
	let target = context.target[context.rename];
	 
	// test source type
	if (!utils.likeObject(source)) return next(utils.ctx(context, new Error(`must be like type Object (not ${utils.typeName(source)})`)));

	// copy source and target
	const prevSource = source; // context.source[context.key];
	context.source[context.key] = Object.assign({}, source);
	let targetCopy;

	// provide target or test provided target type
	if (target === undefined) target = context.target[context.rename] = {}; 
	else if (!utils.likeObject(target)) return next(utils.ctx(context, new Error(`(target) must be like type Object (not ${utils.typeName(target)})`)));
	else targetCopy = Object.assign({}, target);

	handler({}, {}, err => {
		context.source[context.key] = prevSource; // reset source
		if (err) { 
			// reset target
			if (targetCopy) { for (const key in target) delete target[key]; Object.assign(target, targetCopy); }
			else context.target[context.rename] = undefined;
		}
		else
			context.source[context.key] = target;
		next(err);  
	});
}

module.exports.objectSeries = (handlers, next) => {
	async.series(handlers, next);
}

module.exports.objectParallel = (handlers, next) => {
	async.parallel(handlers, next);
}



module.exports.index = (context, index, handler, next) => {
	context.target[context.rename] = context.target[context.rename] || [];
	handler(new Context(context, index), next);
}

//TODO how to handle rename when splitting keys	
module.exports.keys = (context, keys, usedKeys, handler, next) => {
	context.target[context.rename] = context.target[context.rename] || {};
	async.mapSeries(keys, (key, next) => { next = utils.defer(next);
// TODO fix, possibly already handled before called...
		if (key in usedKeys) return next(utils.ctx(context, new Error(`holds duplicate key (${key})`))); 
		usedKeys[key] = true;
		handler(new Context(context, key), utils.defer(utils.nullifyTrue(next)));
	}, next);
}

module.exports.key = (handlers, next) => {
	async.series(handlers, utils.nullifyTrue(next));
}

module.exports.$key = (context, handler, next) => {
	context = new Context(context); // clone context before overriding
	context.source = Object.assign({}, context.source); // clone source before overriding
	context.source[context.key] = { $key: context.key };
	handler(new Context(context, '$key'), next);
}

//
// handle $ attributes, handle incoming errors for ease of use in calling context
//
module.exports.rest = (err, context, usedKeys, handler, next) => { if (err) return next(err);
//TODO test if "source.toObject ? source.toObject() : source" below ever uses toObject() or if already objected in buildObject
	context.target[context.rename] = context.target[context.rename] || {};
	async.forEachOfSeries(context.source[context.key].toObject ? context.source[context.key].toObject() : context.source[context.key], (entry, key, next) => { next = utils.defer(next); // context.key = key;
		if (key in usedKeys) return next(null); // continue (skip rest) if key already handled
		const ctx = new Context(context, key);
		handler(ctx, utils.defer(utils.nullifyTrue(err => { if (err) return next(err);
			// split key with | delimeter (not +)
			const keys = key.split('|').map(key => key.trim());
			
			if (keys.length > 1) {
				keys.map(k => Object.assign(context.target[context.rename], { [k]: ctx.target[key] } ));
				delete ctx.target[key];
			}
			next(null); 
		}))); 
	}, next);
}

//
// seek excessive attributes, handle incoming errors for ease of use in calling context
//
module.exports.excessive = (err, context, usedKeys, ignore, next) => { if (err) return next(err);
	// seek excessive values in source
	async.forEachOfSeries(context.source[context.key].toObject ? context.source[context.key].toObject() : context.source[context.key], (entry, key, next) => { next = utils.defer(next); // context.key = key;
		if (key in usedKeys || key in ignore) return next(); // continue if already handled or to be ignored
		next(utils.ctx(context, new Error(`.${key} is excessive, expected any of [${Object.keys(usedKeys)}]`))); 
	}, next);
}

module.exports.any = (context, handlers, next) => {
	async.series(handlers, (found, errors) => next(found ? null : utils.listStringArray(context, errors)));
}

module.exports.anyOption = (context, handler, next) => {
	(next => handler(next))(utils.filterOutTrue(context, next));
}

module.exports.switch = (handlers, next) => {
	async.series(handlers, utils.nullifyTrue(next));
}

module.exports.switchOption = (handler, next) => {
	(next => handler(next))(utils.flipTrueNull(next));
}

module.exports.series = (handlers, next) => {
	async.series(handlers, next);
}

const postTransform = 
module.exports.postTransform = (err, context, rename, value, process, next) => { 
	if (err) return next(err);
	context.target[rename] = value in { undefined: 1, null: 1 } ? context.source[context.key] : value;
	if (process) return process(context.shift(), context.source[context.key], (err, value, process) => postTransform(err, context, rename, value, process, next));
	next();
}

module.exports.map = (context, map, next) => {
	let value = context.source[context.key]; // TODO rename value to source 
	if (utils.likeObject(map)) {
		if (!utils.isType(value, String)) return next(utils.ctx(context, new Error(`must map with type String (not ${utils.typeName(value)})`)));
		if (! (value in map)) 			  return next(utils.ctx(context, new Error(`must be included in ${utils.jsformat(Object.keys(map))}`)));
		value = map[value];
	} else if (utils.likeArray(map)) {
		if (!utils.isType(value, Number)) return next(utils.ctx(context, new Error(`must map with type Number (not ${utils.typeName(value)})`)));
		if (! (value in map)) 			  return next(utils.ctx(context, new Error(`must be in range of ${utils.jsformat([0, map.length - 1])}`)));
		value = map[value];
	} else {
		if (!utils.isObject(map)) 		  return next(utils.ctx(context, new Error(`cannot map into type ${utils.typeName(map)}, is not Object or Array`)));
	}
	context.source[context.key] = value;
	next(null);
}

module.exports.mapFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$map', next),
		(value, next) => validate(context, '$map', value, globals.collectionTypes, next),
		(value, next) => module.exports.map(context, value, next),
	], next);
}

module.exports.toObject = (context, key, next) => {
	const target = context.target[context.rename]; 
if (!utils.isArray(target)) console.log(7474, context);	
	if (!utils.isArray(target)) 			  return next(new Error(`cannot convert to Object, is not an Array`));
	let i = -1; async.reduce(target, {}, (object, item, next) => { next = utils.defer(next); ++i;
		if (!utils.isObject(item)) 			  return next(new Error(`[${i}] must be an object for array to convert to object`));
		if (! (key in item)) 				  return next(new Error(`[${i}] has no object key: ${key}`));
		if (!utils.isType(item[key], String)) return next(new Error(`[${i}] has non-String object key: ${key}`));
		if (object[item[key]] !== undefined)  return next(new Error(`[${i}] has duplicate object key: ${key} (${item[key]})`));
		object[item[key]] = item;
		delete item[key];
		next(null, object);
	}, (err, object) => { if (err) return next(utils.ctx(context, err));
		context.target[context.rename] = object;
		next(null);
	});
}

module.exports.toObjectFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$toObject', next),
		(value, next) => validate(context, '$toObject', value, globals.nameType, next),
		(value, next) => module.exports.toObject(context, value, next),
	], next);
}

module.exports.toArray = (context, key, next) => {
	const target = context.target[context.rename]; 
	if (!utils.isObject(target)) 				return next(new Error(`cannot convert to Array, is not an Object`));
	async.mapSeries(Object.entries(target), (item, next) => { next = utils.defer(next); 
		if (!utils.isObject(item[1]))        	return next(new Error(`.${item[0]} must be an object for object to convert to array`));
		if (item[1][key] !== undefined) 		return next(new Error(`.${item[0]} already has object key: ${key} (${item[1][key]})`));
		item[1][key] = item[0];
		next(null, item[1]);
	}, (err, array) => { if (err) return next(utils.ctx(context, err));
		context.target[context.rename] = array;
		next(null);
	});
}

module.exports.toArrayFunc = (context, func, next) => {	
	async.waterfall([
		next => module.exports.function(context, func, '$toArray', next),
		(value, next) => validate(context, '$toArray', value, globals.nameType, next),
		(value, next) => module.exports.toArray(context, value, next),
	], next);
}


//
// wrap next-arguments to avoid zero or multiple callbacks
//
function exactlyOnce(context, modifier, next) {
	let timer;
	if (context.scope.timeout) timer = setTimeout(() => {
		next(utils.ctx(context, new Error(`.${modifier} function timed out after ${context.scope.timeout/1000} seconds`)));
	}, context.scope.timeout);
	const f = function(...args) {
		if (timer) clearTimeout(timer);
		// error is thrown (not passed) because caller cannot handle multiple callbacks
		if (next === null) throw new Error(`${context.fullpath()}.${modifier} function already called next()`);
		const next2 = next;
		next = null;
		next2.apply(this, args);
	};
	f.toString = () => next.toString(); // provide transparency to caller
	return f;
}

module.exports.function = (context, func, modifier, next) => {
	try {
		func(context, context.source[context.key], exactlyOnce(context, modifier, (err, ...args) => {
			// setImmediate() to avoid try/catch around next() but only around func()
			setImmediate(() => { 
				if (err) {
					if (err instanceof Error)
						;
					else if (typeof err === 'string' || err instanceof String)
						err = new Error(err);
					else 
						err = new Error(`.${modifier} function returns error value ${utils.jsformat(err)}`); 
					err =  utils.ctx(context, err);
				}
				next(err, ...args);
			});
		}));
	} catch (err) {
		err.message = `.${modifier} function throws error: ${err.message}`;
		next(utils.ctx(context, err));
	}
}

const validate = (context, modifier, value, types, next) => {
	if (types.constructor === Array ? !utils.isAnyType(value, types) : !utils.isType(value, types))
		return next(utils.ctx(context, new Error(`.${modifier} function must return a value of type ${utils.jsformat(types)}, not ${utils.typeName(value)}`)));
	next(null, value);
}

const error = (context, message, value, next) => {
	next(utils.ctx(context, new Error(`${context.message || (message + ' ' + utils.jsformat(value))}`)));
}

module.exports.scope = (context, value, next) => {
	context.scope = Object.assign(context.scope, value); 
	next(null); 
}

module.exports.scopeFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$scope', next),
		(value, next) => validate(context, '$scope', value, globals.scopeType, next),
		(value, next) => module.exports.scope(context, value, next),
	], next);
}

module.exports.insert = (context, value, next) => {
	context.source[context.key] = value; 
	next(null); // continue remaining assertions
}

module.exports.insertFunc = (context, func, next) => {	
	async.waterfall([
		next => module.exports.function(context, func, '$insert', next),
		(value, next) => module.exports.insert(context, value, next),
	], next);	
}

module.exports.default = (context, value, next) => {
	if (context.key in context.source) return next(null); // lazy evaluate
	context.source[context.key] = value; 
	next(null); // continue remaining assertions
}

module.exports.defaultFunc = (context, func, next) => {	
	if (context.key in context.source) return next(null); // lazy evaluate 
	async.waterfall([
		next => module.exports.function(context, func, '$default', next),
		(value, next) => module.exports.default(context, value, next),
	], next);	
}

module.exports.optional = (context, optional, next) => {
	if (context.key in context.source) return next(null); // lazy evaluate
	if (optional === false) return utils.mustBeProvided(context, next);
	next(true); // skip remaining assertions
}

module.exports.optionalFunc = (context, func, next) => {
	if (context.key in context.source) return next(null); // lazy evaluate 
	async.waterfall([
		next => module.exports.function(context, func, '$optional', next),
		(value, next) => validate(context, '$optional', value, globals.booleanType, next),
		(value, next) => module.exports.optional(context, value, next),
	], next);
}

module.exports.rename = (context, renamed, rename, next) => { 
	renamed[context.rename = rename] = true; 
	next(null); 
}

module.exports.renameFunc = (context, renamed, func, next) => { 
	async.waterfall([
		next => module.exports.function(context, func, '$rename', next),
		(value, next) => validate(context, '$rename', value, globals.nameType, next),
		(value, next) => module.exports.rename(context, renamed, value, next),
	], next);
}

module.exports.assign = (context, next) => {
	context.target[context.rename] = context.source[context.key]; 
	next(null);
}

module.exports.remove = (context, next) => {
	delete context.target[context.rename]; 
	next(null);
}

module.exports.removeFunc = (context, func, next) => {	
	async.waterfall([
		next => module.exports.function(context, func, '$remove', next),
		(value, next) => validate(context, '$remove', value, globals.booleanType, next),
		(value, next) => value ? module.exports.remove(context, next) : next(null),
	], next);
}

module.exports.message = (context, value, next) => {
	context.message = value;
	next(null);
}

module.exports.messageFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$message', next),
		(value, next) => validate(context, '$message', value, globals.messageType, next),
		(value, next) => module.exports.message(context, value, next),
	], next);
}

module.exports.length = (context, value, next) => {
	if (utils.length(context.source[context.key]) == value) return next(null);
	next(utils.ctx(context, new Error(`must have exact length ${utils.jsformat(value)}`)));
}

module.exports.lengthFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$length', next),
		(value, next) => validate(context, '$length', value, globals.lengthType, next),
		(value, next) => module.exports.length(context, value, next),
	], next);
}

module.exports.minlen = (context, value, next) => {
	if (utils.length(context.source[context.key]) >= value) return next(null);
	next(utils.ctx(context, new Error(`must have minimum length ${utils.jsformat(value)}`)));
}

module.exports.minlenFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$minlen', next),
		(value, next) => validate(context, '$minlen', value, globals.lengthType, next),
		(value, next) => module.exports.minlen(context, value, next),
	], next);
}

module.exports.maxlen = (context, value, next) => {
	if (utils.length(context.source[context.key]) <= value) return next(null);
	next(utils.ctx(context, new Error(`must have maximum length ${utils.jsformat(value)}`)));
}

module.exports.maxlenFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$maxlen', next),
		(value, next) => validate(context, '$maxlen', value, globals.lengthType, next),
		(value, next) => module.exports.maxlen(context, value, next),
	], next);
}

module.exports.name = (context, value, next) => {
	if (utils.name(context.source[context.key]) == value) return next(null);
	next(utils.ctx(context, new Error(`must have name ${utils.jsformat(value)}`)));
}

module.exports.nameFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$name', next),
		(value, next) => validate(context, '$name', value, globals.nameType, next),
		(value, next) => module.exports.name(context, value, next),
	], next);
}

module.exports.constructor = (context, value, next) => {
	if (utils.constructor(context.source[context.key]) == value) return next(null);
	next(utils.ctx(context, new Error(`must have constructor name ${utils.jsformat(value)}`)));
}

module.exports.constructorFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$constructor', next),
		(value, next) => validate(context, '$constructor', value, globals.nameType, next),
		(value, next) => module.exports.constructor(context, value, next),
	], next);
}

module.exports.lt = (context, value, next) => {
	if (context.source[context.key] < value) return next(null);
	error(context, 'must be less than', value, next);
}

module.exports.ltFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$lt', next),
		(value, next) => validate(context, '$lt', value, globals.scalarTypes, next),
		(value, next) => module.exports.lt(context, value, next),
	], next);
}

module.exports.lte = (context, value, next) => {
	if (context.source[context.key] <= value) return next(null);
	error(context, 'must be less than or equal to', value, next);
}

module.exports.lteFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$lte', next),
		(value, next) => validate(context, '$lte', value, globals.scalarTypes, next),
		(value, next) => module.exports.lte(context, value, next),
	], next);
}

module.exports.eq = (context, value, next) => {
	if (context.source[context.key] == value) return next(null);
	error(context, 'must be equal to', value, next);
}

module.exports.eqFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$eq', next),
		(value, next) => validate(context, '$eq', value, globals.scalarTypes, next),
		(value, next) => module.exports.eq(context, value, next),
	], next);
}

module.exports.ne = (context, value, next) => {
	if (context.source[context.key] != value) return next(null);
	error(context, 'must be different from', value, next);
}

module.exports.neFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$ne', next),
		(value, next) => validate(context, '$ne', value, globals.scalarTypes, next),
		(value, next) => module.exports.ne(context, value, next),
	], next);
}

module.exports.gte = (context, value, next) => {
	if (context.source[context.key] >= value) return next(null);
	error(context, 'must be greater than or equal to', value, next);
}

module.exports.gteFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$gte', next),
		(value, next) => validate(context, '$gte', value, globals.scalarTypes, next),
		(value, next) => module.exports.gte(context, value, next),
	], next);
}

module.exports.gt = (context, value, next) => {
	if (context.source[context.key] > value) return next(null);
	error(context, 'must be greater than', value, next);
}

module.exports.gtFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$gt', next),
		(value, next) => validate(context, '$gt', value, globals.scalarTypes, next),
		(value, next) => module.exports.gt(context, value, next),
	], next);
}

module.exports.match = (context, value, next) => {
	if (utils.match(context.source[context.key], value)) return next(null); 
	error(context, 'must match', value, next);
}

module.exports.matchFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$match', next),
		(value, next) => validate(context, '$match', value, globals.scalarTypes, next),
		(value, next) => module.exports.match(context, value, next),
	], next);
}

module.exports.in = (context, value, next) => {
	if (utils.includes(value, context.source[context.key])) return next(null); 
	error(context, 'must be included in', value, next);
}

module.exports.inFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$in', next),
		(value, next) => validate(context, '$in', value, globals.collectionTypes, next),
		(value, next) => module.exports.in(context, value, next),
	], next);
}

module.exports.nin = (context, value, next) => {
	if (!utils.includes(value, context.source[context.key])) return next(null); 
	error(context, 'must be excluded from', value, next);
}

module.exports.ninFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$nin', next),
		(value, next) => validate(context, '$nin', value, globals.collectionTypes, next),
		(value, next) => module.exports.nin(context, value, next),
	], next);
}

module.exports.inc = (context, value, next) => {
	if (utils.includes(context.source[context.key], value)) return next(null); 
	error(context, 'must include', value, next);
}

module.exports.incFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$inc', next),
		(value, next) => validate(context, '$inc', value, globals.scalarTypes, next),
		(value, next) => module.exports.inc(context, value, next),
	], next);
}

module.exports.ninc = (context, value, next) => {
	if (!utils.includes(context.source[context.key], value)) return next(null); 
	error(context, 'must exclude', value, next);
}

module.exports.nincFunc = (context, func, next) => {
	async.waterfall([
		next => module.exports.function(context, func, '$ninc', next),
		(value, next) => validate(context, '$ninc', value, globals.scalarTypes, next),
		(value, next) => module.exports.ninc(context, value, next),
	], next);
}