'use strict';
const format = require('util').format;
const async = require('async');
const fs = require('fs');
const Context = require('./context');

//compiledFilters
//
//defer
//typeName
//isType...
//
//buildObject
//buildArray
//
//filterSpec
//filterRest
//seekExcessive
//
//nullifyTrue
//


	
//function shallowEqual(object1, object2) {
//	const keys1 = Object.keys(object1);
//	const keys2 = Object.keys(object2);
//  	if (keys1.length !== keys2.length) return false;
//  	for (let key of keys1) if (object1[key] !== object2[key]) return false;
//  	return true;
//}
//function assertSourceAndTarget(context, source, target) {
//	if (! shallowEqual(context.source, source)) {
//		console.log(context.source)
//		console.log(source)
//		throw new Error('bad source assertion');
//	}
//	if (! shallowEqual(context.target, target)) {
//		console.log(context.target)
//		console.log(target)
//		throw new Error('bad target assertion');
//	}
//}

//module.exports.includes2 = (a, b, message) => {
//if (isArray(a))
//	return a.find(item => match(b, item)) !== undefined;
//if (isObject(a)) 
//	return b in a;
//return 'must be array or object, not';
//}
//
//module.exports.compare = (iv, fv, message) => {
//if (iv === null) return `cannot be ${iv}`;
//if (fv === null) return `cannot compare to ${fv}`;
//if (iv === fv) return;
//return message || `must equal ${fv}`
//}


//TODO remove, for testing only
function similar(source, target) {
	if (target === undefined) return false;
	if (source === null) return source === target;
	if (! (isObject(source) && isObject(target))) return false; // compare objects only
	
	const s = Object.keys(source);
	const t = Object.keys(target);
	const x = new Set([...s, ...t]);
	return (s.length == x.size && t.length == x.size);	
}
//TODO for testing, remove
const show = module.exports.show = (next, comment) => {
	return (...args) => {
		console.log(comment || '', ...args);
		next(...args);
	}
}
const trace = module.exports.trace = (next, comment) => {
	return (...args) => {
		console.trace(comment || '', ...args);
		next(...args);
	}
}

// *********************************************************************************************


const modifiers = module.exports.modifiers = [];

module.exports.isModifier = (key) => {
	return modifiers.includes(key);
}

const staticFilters = module.exports.staticFilters = {}; 
const compiledFilters = module.exports.compiledFilters = {}; 
const intrinsicFilters = module.exports.intrinsicFilters = {}; 
const intrinsic = module.exports.intrinsic = { filter: {} };

const systemFilters = module.exports.systemFilters = {};


const nullFilter = module.exports.Filter = (context, functions, renamed, next) => {
	// null-filter
	context.target[context.rename] = context.source[context.key];
	next();
}
nullFilter.functions = [];

//
// execute filter
//
const execute = module.exports.execute = (context, filter, next) =>  {
	if (filter === undefined) throw new Error('undefined filter was executed'); 
	async.waterfall([
		next => {
			if (context.constructor === Context) return next(null, context);
			return next(null, new Context(context));
		},
		(context, next) => {
			// filter is null use null filter
			if (filter === null) return next(null, context, nullFilter); 
			// if filter was compiled (as expected)
			if (isFilter(filter)) return next(null, context, filter);
			console.log('***\n   Warning: executed jsxl filters should be pre-compiled, will be compiled without options   \n***');
			console.log(filter);
// TODO this compiler is not reachable
throw new Error('compiler is unreachable')
			compile(filter, (err, filter) => next(err, context, filter));
		},
		(context, filter, next) => {
			filter(context, filter.functions, [], err => {
				if (err && err !== true) {
					if (! (err instanceof Error)) 
						throw new Error(`Not a proper error: ${err.constructor.name} = ${err}`)
					if (!err.action) err.action = 'Runtime';
					return next(err); 
				}
				next(null, context.target[context.rename]); // promote result thru next
			});
		}
	], next);
}

//
//log to console or write to file
//
const peep = module.exports.peep = (string, inspect) => {
	if (inspect === undefined) return string;
	if (inspect === true)
		console.log(string);
	else if (inspect !== false) {
		try {
			const fd = fs.openSync(inspect, 'w');
			fs.writeSync(fd, string);
			fs.closeSync(fd);
		} catch(err) {
			console.log(format('Cannot write file %s', inspect));
			return peep(string, true); // console if file cannot open
		}
	}
	return string;
}

//
// wrap all next-parameters used in async.keySeries-functions in setImmediate to avoid async-stack-overflow
//
const defer = module.exports.defer = (next) => {
//	console.log(6299, 'fix jsxl defer')
//	return next; // for debugging only
	if (next.name == 'defer') return next; 
	return function(...args) {
		return setImmediate(() => { next(...args); });
	}
}

//
// add context to err
// allow usage like "next(ctx(err))", even when err is undefined or null
// allow usage like "ctx(next)", where next simply passes err
//
const ctx = module.exports.ctx = (context, object) => {
	if (object === undefined || object == null) return object;
	if (isFunction(object)) return (...args) => {
		const next = args[args.length - 1];
		args[args.length - 1] = (...args) => {
			ctx(context, args[0])
			next(...args); 
		} 
		object(...args);
	};
	object.ctx = context;
	return object;
}

module.exports.hashString = (s) => {
	const base = '0123456789ABCDEF', a = [];
	for (let i = 0; i < s.length; i++) a[i % base.length] = ((a[i % base.length] || 0) + s.charCodeAt(i)) % base.length;
	for (let i = 0; i < a.length; i++) a[i] = base.substring(a[i], a[i] + 1);
	return a.join('');
}

const nullifyTrue = module.exports.nullifyTrue = (next) => {
	return (err, ...args) => {
		if (err === true) err = null;
		next(err, ...args);
	};
}
const flipTrueNull = module.exports.flipTrueNull = (next) => {
	return (err, ...args) => {
		if (err === true) err = null;
		else if (err === null) err = true;
		next(err, ...args);
	};
}
const filterOutTrue = module.exports.filterOutTrue = (context, next) => {
	return err => next(err ? null : true, err === true ? ctx(context, new Error(`was filtered out`)) : err);
}

module.exports.overlap = (a, b) => {
	return new Set([...a, ...b]).size < new Set(a).size + new Set(b).size;
}
module.exports.identical = (a, b) => {
	return new Set([...a, ...b]).size == new Set(a).size && new Set(a).size == new Set(b).size;
}
module.exports.subset = (a, b) => {
	return new Set([...a, ...b]).size == new Set(a).size && new Set(a).size >= new Set(b).size;
}

const likeArray = module.exports.likeArray = (element) => {
	if (element === null || element === undefined) return false;
	return typeof element === 'object' && typeof element[Symbol.iterator] === 'function';
}
const likeObject = module.exports.likeObject = (element) => {
	if (element === null || element === undefined) return false;
	return typeof element === 'object' && typeof element[Symbol.iterator] !== 'function' && element.constructor.name !== 'Date';
}
const isArray = module.exports.isArray = (element) => {
	if (element === null || element === undefined) return false;
	return element.constructor.name === 'Array';
}
const isObject = module.exports.isObject = (element) => {
	if (element === null || element === undefined) return false;
	return typeof element === 'object' && element.constructor.name !== 'Array' && element.constructor.name !== 'Date';
}
const isFilter = module.exports.isFilter = (element) => {
	if (element === null || element === undefined) return false;
	return element.constructor === Function && element.compiler; 
}
const isType = module.exports.isType = (element, type) => {
	if (element === null || element === undefined) return false;
	return element.constructor === type; 
}
const isTypeName = module.exports.isTypeName = (element, type) => {
	if (element === null || element === undefined) return false;
	return element.constructor.name === type; 
}
const isAnyType = module.exports.isAnyType = (element, types) => {
	if (element === null || element === undefined) return false;
	return types.includes(element.constructor); 
}
const typeName = module.exports.typeName = (element) => {
	if (element === null) return 'null';
	if (element === undefined) return 'undefined';
	return element.constructor.name;
}
const isFunction = module.exports.isFunction = (element) => {
	if (element === null || element === undefined) return false;
	return element.constructor === Function; 
}
//module.exports.isModifierFunction = (element) => {
//	if (element === null || element === undefined) return false;
//	return element.constructor === Function && element.name[0] == '$';
//}
module.exports.isNative = (element) => {
	if (element === null || element === undefined) return false;
	return [Boolean, Number, String, RegExp, Date, Function, Array, Object].includes(element);
}

module.exports.length = (a) => {
	if (a === null || a === undefined) return undefined;
	return a.length;
}

module.exports.name = (a) => {
	if (a === null || a === undefined) return undefined;
	return a.name;
}

module.exports.constructor = (a) => {
	if (a === null || a === undefined) return undefined;
	return a.constructor.name;
}

const match = module.exports.match = (a, b) => {
	return isType(a, String) && (isType(b, RegExp) || isType(b, String)) ? a.match(b) : a == b;
}

module.exports.includes = (a, b) => {
	return isArray(a)  ?              a.find(item => match(item, b)) !== undefined : 
		   isObject(a) ? Object.keys(a).find(item => match(item, b)) !== undefined : 
			                        [a].find(item => match(item, b)) !== undefined;
}

//
// format value javascript style, tab used for function identation
//
const jsformat = module.exports.jsformat = (value, tab) => { tab = tab || 0;
	if (value === undefined) return 'undefined';
	if (value === null) return 'null'; 
	switch (value.constructor) {
	case String  : return JSON.stringify(value);
	case RegExp  : 
	case Boolean : 
	case Number  : return value.toString();
	case Date    : return format('new Date(%d)', value);  
	case Function: {
		if ([ String, RegExp, Boolean, Number, Date, Function, Array, Object ].indexOf(value) > -1) return value.name;
		const t = ((value.toString().match(/\n\s*}$/) || [''])[0].match(/( {0,3}\t| {4})/g) || []).length; // count tabs in front of trailing function bracket
		return value.toString().replace(new RegExp(format('\r?\n( {0,3}\t| {4}){%d}', t), 'g'), format('\n%s', Array(tab + 1).join('\t')));
	}
	case Array   : return format("[ %s ]", value.reduce((acc, value) => acc + (acc.length > 0 ? ", " : "") + format("%s", jsformat(value, tab)), ''));
	case Object  : // same as default
	default      : return format("{\n%s%s\n%s}",
						Array(tab + 2).join('\t'),
						Object.entries(value).reduce((acc, [key, value]) => acc + (acc.length > 0 ? (",\n" + Array(tab + 2).join('\t')) : "") + format("%s: %s", key.match(/^[_a-z][_a-z0-9]*$/i) ? key : JSON.stringify(key), jsformat(value, tab + 1)), ''),
						Array(tab + 1).join('\t')
				   )
	}
}

//
//return array length (index of next) and push element into array
//
const pushReturnLength = module.exports.pushReturnLength = (array, entry) => {
	array.push(entry);
	return array.length - 1;
}

//
//
//
//const extendContext = module.exports.extendContext = (context, key) => {
//	const context2 = {}; 
//	for (const k in context) context2[k] = context[k];
//	context2.context = context;
//	context2.key = key;
//	return context2;
//}

module.exports.mustBeProvided = (context, next) => {
	next(ctx(context, new Error(`must be provided`)));
}

//listing all errors on type $any
module.exports.listStringArray = (context, array) => {
	array = array.filter(i => i !== true); // remove true-errors
	switch(array.length) {
	case 0: return null;
	case 1: return array[0];
	default: 
		return array.reduce((acc, err, i) => {
//			if (i < array.length - 1) return `${acc}\n${err.message || err}${array.length > 2 ? ',' : ''}`;
//			return ctx(context, new Error(`${acc} or\n${err.message || err}`));
			
			if (i < array.length - 1) return `${acc}\n${errorPrefix(err)}${array.length > 2 ? ',' : ''}`;
			return new Error(`${acc} or\n${errorPrefix(err)}`);
		}, 'one of'); 
	}
}

const errorPrefix = module.exports.errorPrefix = (err) => {
	const location = undefined;
//	const location = err.stack && err.stack.match(/(\n)([' ']*)(at.*)(\n)/)[3];
	return `${err.ctx ? err.ctx.fullpath() : err.message.match(/^one of/) ? '' : '(missing context)'}${['.', '['].includes(err.message[0]) || err.message.match(/^one of/) ? '' : ' '}${err.message + (location ? ', ' + location : '')}`;
}

//
//
//
const merge = module.exports.merge = (target, ...sources) => {
	if (sources.length == 0) return target;
	let source = (sources.length == 1) ? sources[0] : merge(...sources);
	
	if (target === undefined) return source;
	if (source === undefined) return target;

	function isModified(object) {
		if (object === null) return 7; // simple
		if (object.constructor === Array) return 1 // array
		let mod = 7; // simple
		if (object.constructor === Object) {
			mod = 2; // object
			for (const key in object) {
				if (modifiers.includes(key))
					switch (key) {
					case '$switch':	mod = Math.max(mod, 6);
					case '$any':   	mod = Math.max(mod, 5);
					default:       	mod = Math.max(mod, 3);
					}
			}
		}
		return mod;
	}
	//
	//	identify characteristics
	// 	1 arrays
	//	2 objects
	//	3 complex $type
	//  4 <reserved>
	// 	5 complex $any
	// 	6 complex $switch
	// 	7 simple
	//

//	complex-complex	mergeObjects(complex, complex)			356-356		*
//	complex-simple	mergeObjects(complex, complex(simple))	356-7			*
//	complex-object	mergeObjects(complex, complex(object))	356-2			*
//	complex-array	mergeObjects(complex, complex(array))	356-1			*
//
//	simple-complex	mergeObject(complex(simple), complex)	7-356			*
//	simple-simple	simple									7-7				*
//	simple-object	object									7-2				*
//	simple-array	array									7-1				*
//
//	object-complex	mergeObjects(complex(object), complex)	2-356			*
//	object-simple	simple									2-7				*
//	object-object	mergeObjects(object, object)			2-2				---
//	object-array	array									2-1				*
//
//	array-complex	mergeObjects(complex(array), complex)	1-356			*
//	array-simple	simple									1-7				*
//	array-object	object									1-2				*
//	array-array		mergeArrays(array, array)				1-1				---

	// prepare before merging objects (on break) or 
	switch (isModified(target) * 10 + isModified(source)) {
	// 356-356
	case 33:																// type-type
	case 55: 																// any-any
	case 66: break;															// switch-switch
	case 35: 																// type-any
	case 36: 																// type-switch
	case 53: 																// any-type
	case 63: 																// switch-type
//	case 56: throw new Error('not yet supported');	// any-switch
//	case 65: throw new Error('not yet supported');	// switch-any 

	// 356-721
	case 37: 																// type-simple
	case 32: 										 						// type-object
	case 31: source = { $type:     source   }; break; 						// type-array
	case 57:																// any-simple
	case 52:																// any-object
	case 51: source = { $any:    [ source ] }; break;						// any-array
	case 67:																// switch-simple
	case 62:																// switch-object
	case 61: source = { $switch: [ source ] }; break;						// switch-array

	// 721-356
	case 73: 																// simple-type
	case 23: 																// object-type
	case 13: target = { $type:     target   }; break; 						// array-type
	case 75: 																// simple-any
	case 25: 																// object-any
	case 15: target = { $any:    [ target ] }; break;						// array-any
	case 76: 																// simple-switch
	case 26: 																// object-switch
	case 16: target = { $switch: [ target ] }; break;						// array-switch

	case 77:
	case 72:
	case 71: 
	case 27: 
	case 21: 
	case 17:
	case 12: return source; 
	
	case 22: break; 
	
	case 11: return mergeArrays(target, source);

	}
	return mergeObjects(target, source);
} 
function mergeArrays(target, source) {
	return target.concat(source);
	
	let x = [ merge(target[0], source[0]) ];
	console.log(1000);
	console.log('-------------------------');
	console.log(target);
	console.log(source);
	console.log(x);
	console.log('-------------------------');
	return x;
}
function mergeObjects(target, source) {
	let result = {};
	for (let key of [...new Set([...Object.keys(target), ...Object.keys(source)])]) result[key] = merge(target[key], source[key]); // Set ensures one occurance only of each key
	return result;
}


