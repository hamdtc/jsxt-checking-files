'use strict';
const jsxl = require('../lib/jsxl');

//********************************************************************************************************

//TESTING

//***************************************************************************************************** 

var filter = [{ age: { $type: Number, $optional: true, $transform: (ctx, age, next) => { next(null, age * 2); }}, name: String }]

var input = [{ name: 'jane'}, { name: 'poul', age: 9 }]

var output = {
}


//console.log('------------------------');
//const e = new Error('test');
////console.log(777, e);
//e.stack = `Error: wow ${e.stack.substring(7)}`;
//e.message = `wow ${e.message}`;
//console.log(888, e.message);
//console.log(999, e);
//process.exit();


let providers = {
	aws: {
		subnets: /^[a-z_][a-z_0-9]+$/,
		regions: {
			"ap-south-2": [ 'a', 'b', 'c'],
			"us-east-1":  [ 'a', 'b', 'c'],
			"eu-west-1":  [ 'a', 'b', 'c']
		}
	}
}

let providerReference = (context, key, next) => {
	if (key in providers) return next();
	next(`is an invalid provider reference (${key})`);
};

let regionReference = (context, key, next) => {
	if (key in providers[context.context.context.key].regions) return next();
	next(`is an invalid ${context.context.context.key} region reference (${key})`);
};

let zoneReference = (context, key, next) => {
	if (providers[context.context.context.context.context.context.key].regions[context.context.context.context.context.key].includes(key)) return next();
	next(`is an invalid ${context.context.context.context.context.context.key} region ${context.context.context.context.context.key} zone reference (${key})`);
};

let subnetName = (context, key, next) => {
console.log(3333, key.match(providers[context.context.context.context.key].subnets));	
	if (key.match(providers[context.context.context.context.key].subnets)) return next();
	next(`is an invalid ${context.context.context.context.key} subnet name (${key})`);
}

let imageReference = (context, key, next) => {
	if (key in context.root.source[context.root.key].images) return next();
	next(`is an invalid image reference (${key})`);
};

filter = {
	images: {
		$: { // images
			ingress: { $optional: true, $type: {
				
			}},
			image:  {
				// port and protocol
				// software libraries
				// processes
				// os
			},
			access: { $optional: true, $type: [{ $any: [ String, RegExp ] } ]},
			egress: { $optional: true, $type: {
				
			}},
		}
	},
	stages: {
		$: {
			preconditions: { $optional: true, $type: [
				null
			]},
			providers: {
				$: { // provider references
					$key: { $type: String, $transform: providerReference },
					$type: {
						$: { // region references
							$key: { $type: String, $transform: regionReference},
							$type: {
								$: { // subnet sets
									$key: { $type: String, $transform: subnetName },
									$type: {
										$: { // image references
											$key: { $type: String, $transform: imageReference }, 
											$type: {
												zones: { $type: [ { $type: String, $length: 1, $transform: zoneReference } ], $minlen: 1 },
												count: { $type: [ Number ], $minlen: 1, $maxlen: 2 } 
											}
										}
									}
								}
							}
						}
					}
				},
			},
			tests: { $optional: true, $type: [
				null
			]},
			postconditions: { $optional: true, $type: [
				null
			]}
		}
	}
};

input = {
	images: {
		image1: {
			ingress: {},
			image: {},
			access: [],
			egress: {},
		},
		image2: {
			ingress: {},
			image: {},
			access: [],
			egress: {},
		}
	},
	stages: {
		production: {
			providers: {
				aws: {
					'us-east-1': {
						"subnetset1": {
							image1: {
								zones: ['a', 'b'], 
								count: [ 2, 6 ]
							}
						}
					},
					'eu-west-1': {
						subnetset1: {
							image1: {
								zones: ['a', 'b', 'c'], 
								count: [ 3, 9 ]
							}
						}
					}
				}
			}
		}
	}
};

//filter = {
//	$any: [
//		Date,
//		{
//			$type: String, $transform: (context, string, next) => {
//				let x = Date.parse(string);
//				if (isNaN(x)) return next(new Error(`is not a proper date string (${string})`));
//				next(null, new Date(x));
//			}
//		}
//	]
//}
//input = "2017/05"



if (true) jsxl.compile(
	filter,
	{ inspect: true },
	(err, filter) => { 
		console.log(3456);
		if (err) {
			console.log(9999, err);
			process.exit();
		}
		let n = 0;
		filter.functions.map(f => {
			console.log('--- function', n, '---');
			console.log(f.toString());
		})
		jsxl.execute({input}, filter, (err, result) => {
			console.log(9999, err, JSON.stringify(result, null, 4)); // JSON.stringify(input, null, 4)
			process.exit();
		});
	}
);
if (false) jsxl(
		{input},
		filter,
		{ inspect: true },
		(err, result) => {
			console.log(9999, err, JSON.stringify(input, null, 2), JSON.stringify(result, null, 4));
			process.exit();
		}
	);

//***************************************************************************************************************



