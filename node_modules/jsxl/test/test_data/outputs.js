var outputs = function(){

  /////////////// Outputs for $type modifier  /////////////////////
  this.capitalize = (string) =>{
      if(string != null){
          return string.charAt(0).toUpperCase() + string.slice(1);
      }
    }

  this.outputsForType = (level,mustBe,not)=>{
      var lvl = null;
      (level == '0') ? lvl = 'lvl0' : lvl = 'lvl1.lvl2.str';
      if(not != 'null'){
          return `(Runtime) input.${lvl} must be of type ${this.capitalize(mustBe)} (not ${this.capitalize(not)})`
      }else{
          return `(Runtime) input.${lvl} must be of type ${this.capitalize(mustBe)} (not ${not})`
      }

  }

  //outputs for undefined errors 
  this.stringUndefined = "(Runtime) input.lvl0 must be provided";
  this.stringUndefinedlvl2 = "(Runtime) input.lvl1.lvl2.str must be provided";

  this.typePassGenericFunction = '(Runtime) input.lvl0 must be of type lvl0 (not Function)'
 

  ///////////////////////// Outputs for $filter modifier //////////////////////////

  this.filterTrue = {
      lvl0: 'true',
      lvl1: {
        arrStr: [ true, true, 'test', 34 ],
        lvl2: { str: 'true' }
      }
  }

  this.filterFalse = {
      lvl1: {
          arrStr: [ true, true, 'test', 34 ],
          lvl2: {}
      }
  }

  this.ifString = "(Compile) filter.$type.lvl0.$filter must be of type Function (not String)";
  this.ifBoolean = "(Compile) filter.$type.lvl1.$type.arrStr[0].$filter must be of type Function (not Boolean)";
  this.useAlongsideANonModifier = "(Compile) filter.$type mixes modifier ($filter) with non-modifier (lvl0)";

   //////////////////////// Outputs for $transform ////////////////////////////////////

   this.transform1 = {
      lvl0: 'trueT',
      lvl1: {
        arrStr: [
          'falseT', 'trueT',
          'falseT', 'trueT',
          'nullT',  'testT',
          '34T',    '0T',
          'NaNT'
        ],
        lvl2: { test: 'trueT' }
      }
    };

  this.removeValue = {
      lvl1:{one:1}
  };

  this.nullUndefined = {
      lvl0:"false"
  }

  this.verifyMofifiedValue = { lvl1: { lvl2: 44 }, lvl0: 'fromTransform' }

  this.typeError = "(Compile) filter.$type.lvl0.$transform must be of type Function (not Number)";


  //////////////////////////// Outputs for $remove /////////////////////////////////////////

  this.remove_test = {
      lvl0:'true'
  }

  this.stringerror = "(Compile) filter.$type.lvl1.$remove must be of type Boolean (not String)"
  this.nullError = "(Compile) filter.$type.lvl1.$remove must be of type Boolean (not null)"

   /////////////////////////// $insert, $default outputs /////////////////////////////////

   this.topLvlInsert = "(Runtime) input.lvl0 must be provided";

   this.insertAlllvl = {
    lvl0: 'Inserted value',
    lvl1: { arrStr: '\n', lvl2: { str: 'Inserted\n55' } }
  }

   this.insertNullUndefined = {
       lvl0: null, 
       lvl1: { 
           arrStr: undefined, 
           lvl2: { 
               str: [undefined, 0, null]  
           } 
       } 
   }

   this.insertDifferentTypeError = "(Runtime) input.lvl1.arrStr must be of type Object (not Array)";
   this.useInsertWithRemoveDefault = "(Compile) filter.$type.lvl0.$type filter.$type.lvl0.$type holds multiple of $remove, $insert, or $default modifiers";

   this.insertValues = { lvl0: 25, lvl1: { arrStr: [ 1, 2 ], lvl2: { test: [undefined,0] } } }

   this.defaultOutput = {
       lvl0: 'Defaulted value',
       lvl1: {
         arrStr: [ false, 'Defaulted value', false, null, 'test', 34, 0, NaN ],
         lvl2: { test: ["Defaulted value"] }
       }
     }

     this.defaultValuePresemt = {
      lvl0:'true',
      lvl1:{
          arrStr:[false,true,false,true,null,'test',34,0,NaN],
          lvl2:{
              test:'true'
          }
      }
  }

   this.defaultUndefinedOutput = {
       lvl0: 'undefined\n',
       lvl1: {
         arrStr: [ false, undefined, false, null, 'test', 34, 0, NaN ],
         lvl2: { test: null }
       }
     }

   this.defaultErrorWithType = "(Runtime) input.lvl1.lvl2.test must be of type Array (not null)"

//////////////////////////////////// $optional outputs ////////////////////////////////

 this.optionalTrue = {
  lvl0: 'transformed value',
  lvl1: { arrStr: 'Inserted value', lvl2: { test: true } }
}

this.optionalAtTopError = "(Runtime) input.lvl0 must be provided";
this.optionalAlongWithOtherModifiers = "(Compile) filter.$type.lvl1.$type.arrStr.$type filter.$type.lvl1.$type.arrStr.$type holds any of $remove, $insert, or $default modifiers but is explicitly mandatory (non-optional)"
this.optionalWithOtherDatatype = "(Compile) filter.$type.lvl0.$optional must be of type Boolean (not Number)";

/////////////////////////////////////// $map outputs ///////////////////////////////////////

this.mapWithString = {
  lvl0: 0,
  lvl1: { 
    arrStr: [ [ 'Mapped', undefined, 1, {} ], { '1': undefined, '2': { n: 'g' }, '3': null } ],
    lvl2: { 
      test: true 
    }
  }
}

this.mapUndefinedError = "(Runtime) input.lvl1.arrStr[0] cannot map into type undefined, is not Object or Array";
this.mapOtherdirectly = "(Compile) one of\nfilter.$type.lvl0.$map must be of type Function (not null),\nfilter.$type.lvl0.$map must be of type Array (not null), or\nfilter.$type.lvl0.$map must be of type Object (not null)"

this.mapNumberToArray = {
  lvl0: 44,
  lvl1: {
    arrStr: [ ['a','b'], {1:1}, null],
    lvl2: { test: null }
  }
}

this.mapOtherDattypeInput = "(Runtime) input.lvl0 must map with type String (not Number)"
this.mapOtherDattypeInputFn = "(Runtime) input.lvl1.lvl2.test must map with type String (not Number)"

this.mapToUndefined = "(Runtime) input.lvl1.test must be provided"
this.mapToUndefinedFn = "(Runtime) input.lvl1.lvl2.test must be provided"

this.mapToNull = "(Runtime) input.lvl1.test must map with type String (not null)";
this.mapToNullFn = "(Runtime) input.lvl1.lvl2.test must map with type String (not null)";

this.mapToObject = "(Runtime) input.lvl1.test must map with type String (not Object)";
this.mapToObjectFn = "(Runtime) input.lvl1.lvl2.test must map with type String (not Object)";

this.mapToArray = "(Runtime) input.lvl1.test must map with type String (not Array)";
this.mapToArrayFn = "(Runtime) input.lvl1.lvl2.test must map with type String (not Array)";

this.mapArrToString = "(Runtime) input.lvl1.lvl2.test must map with type Number (not String)"

this.mapUndefinedToArray = "(Runtime) input.lvl0 must be provided"
this.mapUndefinedToArrayFn = "(Runtime) input.lvl1.lvl2.test must be provided"

this.mapNullToArray = "(Runtime) input.lvl0 must map with type Number (not null)"
this.mapNullToArrayFn = "(Runtime) input.lvl1.lvl2.test must map with type Number (not null)";

this.mapObjectToArray = "(Runtime) input.lvl0 must map with type Number (not Object)";
this.mapObjectToArrayFn = "(Runtime) input.lvl1.lvl2.test must map with type Number (not Object)";

this.mapArrayToArray = "(Runtime) input.lvl0 must map with type Number (not Array)";
this.mapArrayToArrayFn = "(Runtime) input.lvl1.lvl2.test must map with type Number (not Array)";

this.mapUndefinedToInteger = "(Runtime) input.lvl0 cannot map into type undefined, is not Object or Array";
this.mapUndefinedToIntegerFn = "(Runtime) input.lvl1.lvl2.test.$map function must return a value of type [ Array, Object ]"

this.mapNullToInteger = "(Compile) one of\nfilter.$type.lvl0.$map must be of type Function (not null),\nfilter.$type.lvl0.$map must be of type Array (not null), or\nfilter.$type.lvl0.$map must be of type Object (not null)"
this.mapNullToIntegerFn = "(Runtime) input.lvl1.lvl2.test.$map function must return a value of type [ Array, Object ]"

this.mapStringToInteger = "(Compile) one of\nfilter.$type.lvl0.$map must be of type Function (not String),\nfilter.$type.lvl0.$map must be of type Array (not String), or\nfilter.$type.lvl0.$map must be of type Object (not String)"
this.mapStringToIntegerFn = "(Runtime) input.lvl1.lvl2.test.$map function must return a value of type [ Array, Object ]"

this.mapInputNotPresentInFilter = '(Runtime) input.lvl1.arrStr[2] must be included in [ "test", "test1" ]'
this.mapOutOfArrayRange = "(Runtime) input.lvl1.arrStr[2] must be in range of [ 0, 6 ]";
this.mapOutOfArrayRangeFn = "(Runtime) input.lvl1.lvl2.test must be in range of [ 0, 6 ]";
this.mapInputOtherThanNumber = "(Runtime) input.lvl0 must map with type Number (not String)"

this.String_Integer_String = { lvl1: { lvl2: { test: 'two' } } }
this.Integer_Integer_String = "(Runtime) input.lvl1.lvl2.test must be of type String (not Number)"
this.String_Integer_Integer = "(Runtime) input.lvl1.lvl2.test must be of type Number (not String)";

this.String_Integer_ObjString = "(Runtime) input.lvl1.lvl2.test (source) must be like type Object (not String)";
this.objString_Integer_ObjString = { lvl1: {lvl2: { test: { three: 3 } }} }
this.objString_Integer_Number = "(Runtime) input.lvl1.lvl2.test must be of type Number (not Object)"
this.objString_Integer_ObjStringB = "(Runtime) input.lvl1.lvl2.test.two must be provided";

///////////////////////////// Comparison outputs ///////////////////////////

this.compareError = "(Runtime) input.lvl0 must be greater than 25";
this.compareError1 = '(Runtime) input.lvl1.arrStr[0] must be greater than or equal to "b"';
this.compareUndefinedFunc = "(Runtime) input.lvl0.$eq function must return a value of type [ Boolean, Number, String, RegExp, Date ]";
this.compareundefinedDir = { lvl0: 30 };
this.compareNewLineFunc = '(Runtime) input.lvl1.arrStr[0] must be equal to "\\n"';
this.compareNewLineDir = '(Runtime) input.lvl1.arrStr[0] must be equal to "\\n"';

this.compareOtherModifiers = {
  lvl0: 'transformedValue',
  lvl1: {
    arrStr: ['c','d','g'],
    lvl2: { test: 'default', test1: 'test' }
  }
}

///////////////////////////// Match outputs ////////////////////////////

this.matchRegexFunc = "(Runtime) input.lvl0 must match /[test][0-5]/"
this.matchRegexDir = "(Runtime) input.lvl1.arrStr[2] must match /[a-f]/"
this.matchString = '(Runtime) input.lvl1.lvl2.test1 must match "rty"'
this.matchUndefined = "(Runtime) input.lvl0.$match function must return a value of type [ Boolean, Number, String, RegExp, Date ]"
// this.matchOtherDatatype = "(Compile) one of\nfilter.$type.lvl1.$type.arrStr[0].$match must be of type Function (not Number),\nfilter.$type.lvl1.$type.arrStr[0].$match must be of type String (not Number), or\nfilter.$type.lvl1.$type.arrStr[0].$match must be of type RegExp (not Number)"
this.matchOtherDatatype = `(Runtime) input.lvl1.arrStr[0] must match 8`
this.matchWithOthermodifier = {
  lvl0: 'test5',
  lvl1: { arrStr: [ true, true, true ], lvl2: { test: 'undefined' } }
}


//////////////////////////////////// Message outputs ///////////////////////////////

this.message = "(Runtime) input.lvl0 Test message from $message"
this.messageTypeError = "(Compile) filter.$type.lvl0.$message must be of type String (not Number)"; 
this.messageTypeError1 = "(Compile) filter.$type.lvl0.$message must be of type String (not null)";
this.messageTypeError2 = "(Compile) filter.$type.lvl0.$message must be of type String (not Function)"

this.msgNewLineMsg = "(Runtime) input.lvl0 \n"


//////////////////////////////////// Rename outputs ///////////////////////////////////////

this.renameKeys = {
  RenameAt0: 'test66',
  lvl1: { arrStr: [ 'b', 5 ], lvl2: { RenamedAt2: 'undefined' } }
}

this.renameInsideArray = '(Compile) filter.$type.lvl1.$type.arrStr[0].$rename cannot rename when inside array'

this.renameOtherDatatype = "(Compile) one of\nfilter.$type.lvl0.$rename must be of type Function (not Number) or\nfilter.$type.lvl0.$rename must be of type String (not Number)"
this.renamePassNull = "(Compile) one of\nfilter.$type.lvl0.$rename must be of type Function (not null) or\nfilter.$type.lvl0.$rename must be of type String (not null)"

this.renameUndefined = {
  lvl0: 'test66',
  lvl1: { '5': [ 'b', 5 ], lvl2: { RenamedAt2: 'undefined' } }
}

this.renameOtherDatatypesFunc = '(Runtime) input.lvl0.$rename function must return a value of type String'

this.renameOtherModifiers = {
  renamelvl1: { renameArr: [ 'b', 'a' ], renameLvl2: { Function: '22' } }
}

this.renameNewLine = {
  '\n': 'test66',
  lvl1: {
    arrStr: [ 'b', 5 ],
    lvl2: { 'lvl3Test': 'undefined' }
  }
}

this.renamePassFunc = '(Runtime) throws error: Unexpected identifier'

////////////////////////////////// Array length outputs ///////////////////////////////////

this.lengthMax = '(Runtime) input.lvl0 must have maximum length 3'
this.lengthMin = "(Runtime) input.lvl1.arrStr must have minimum length 3"
this.lengthLen = "(Runtime) input.lvl1.lvl2.test must have exact length 1"

this.lengthTypeError = "(Compile) one of\nfilter.$type.lvl0.$maxlen must be of type Function (not String) or\nfilter.$type.lvl0.$maxlen must be of type Number (not String)"
this.lengthTypeError1 = "(Compile) one of\nfilter.$type.lvl0.$maxlen must be of type Function (not null) or\nfilter.$type.lvl0.$maxlen must be of type Number (not null)"

this.lengthErrorFunc = "(Runtime) input.lvl1.arrStr.$minlen function must return a value of type Number";
this.lengthErrorObj = "(Runtime) input.lvl1.arrStr.$minlen function must return a value of type Number"
this.lengthUndefined = "(Runtime) input.lvl1.arrStr.$minlen function must return a value of type Number";

this.lengthWithOtherModifier = { lvl0: [ 0, 1, 2 ], lvl1: { arrStr: '123', lvl2: { test: [ 1, 2 ] } } }

////////////////////////////////////  Includes Outputs  ///////////////////////////////////////////

this.inFail = "(Runtime) input.lvl0 must be included in [ null, 0 ]"
this.ninFail = "(Runtime) input.lvl1.arrStr[3] must be excluded from {\n\ttrue: 1\n}"

this.inNewLineInArray = {
lvl0: null,
lvl1: { arrStr: [ 'b', [ 'a' ], 0 ], lvl2: { test: Infinity } }
}

this.inStringError = "(Compile) one of\nfilter.$type.lvl0.$in must be of type Function (not String),\nfilter.$type.lvl0.$in must be of type Array (not String), or\nfilter.$type.lvl0.$in must be of type Object (not String)"
this.inNullError = "(Compile) one of\nfilter.$type.lvl0.$in must be of type Function (not null),\nfilter.$type.lvl0.$in must be of type Array (not null), or\nfilter.$type.lvl0.$in must be of type Object (not null)"

this.inOtherModifier = { lvl0: 5, lvl1: { arrStr: '123', lvl2: { test: [12] } } }

this.incError = "(Runtime) input.lvl0 must include true"
this.incFailAtTop = "(Runtime) input.lvl1 must be provided"
this.PassFuncKeyword = '(Runtime) throws error: Unexpected identifier'

this.nincFail = "(Runtime) input.lvl1.lvl2.test must exclude 1"

this.incTypeError = "(Compile) one of\nfilter.$type.lvl0.$inc must be of type Function (not Array),\nfilter.$type.lvl0.$inc must be of type Boolean (not Array),\nfilter.$type.lvl0.$inc must be of type Number (not Array),\nfilter.$type.lvl0.$inc must be of type String (not Array),\nfilter.$type.lvl0.$inc must be of type RegExp (not Array), or\nfilter.$type.lvl0.$inc must be of type Date (not Array)"
this.incTypeError1 = "(Compile) one of\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type Function (not Object),\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type Boolean (not Object),\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type Number (not Object),\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type String (not Object),\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type RegExp (not Object), or\nfilter.$type.lvl1.$type.lvl2.$type.test.$inc must be of type Date (not Object)"
this.incTypError2 = "(Runtime) input.lvl1.arrStr.$inc function must return a value of type [ Boolean, Number, String, RegExp, Date ]";

this.incWithOtherModifier = '(Runtime) input.lvl1.lvl2 must exclude "renamed"';

this.inPassNumViaFunc = "(Runtime) input.lvl1.arrStr[0].$in function must return a value of type [ Array, Object ]"

this.incPassNewLineDir = {
lvl0: [ undefined, true, null, Infinity, '\n' ],
lvl1: { arrStr: [ 'test', 1, 5 ], lvl2: { test: { one: 1, true: false } } }
}

this.incPassNumberInput = "(Runtime) input.lvl1.arrStr must be of type array or object and include 5"
this.incPassStringInput = "(Runtime) input.lvl0 must include true"

///////////////////////////////// $toObject Outputs ///////////////////////////////////////

this.toObjectPass = {
lvl0: { '55': {} },
lvl1: {
  arrObj: {
    '99': { '4': 8, test1: 56, test: 55 },
    kkll: { '55': 88, true: false }
  }
}
}

this.toObjFailNumber = "(Compile) filter.$type.lvl0.$toObject must be of type String (not Number)"
this.toObjFailFunc = "(Compile) filter.$type.lvl0.$toObject must be of type String (not Function)"
this.toObjStrInput = "(Runtime) input.lvl0 cannot convert to Object, is not an Array"
this.toObjStrInputlvl1 = "(Runtime) input.lvl1.arrObj cannot convert to Object, is not an Array"
this.toObjNoKey = "(Runtime) input.lvl0[0] has no object key: test"
this.toObjStrKey = "(Runtime) input.lvl0[0] has non-String object key: test"
this.toObjUndefinedKey = "(Runtime) input.lvl1.arrObj[0] has no object key: lvl1"

this.toObjectWithOtherModifier = {
lvl0: { '66': {} },
lvl1: {
  arrStr: [ { lvl2: { '11': {} } } ]
}
}


///////////////////////////////////////// toArray outputs //////////////////////////////////////////////

this.toArrayPass = {
  lvl0: [ { one: 1, two: 2, '\n': 'test' } ],
  lvl1: {
    arrStr: [
      { lvl2: [ { '5': 6, lastLvl: 'lvl3' } ] }
    ]
  }
}

this.toArrayNull = "(Compile) filter.$type.lvl0.$toArray must be of type String (not null)"

this.toArrayOtherMod = {
renamed: [ { one: 1, two: 2, '\n': 'test' } ],
lvl1: {
  arrStr: [
    { lvl2: [ { '5': 6, lastLvl: 'lvl3' } ] }
  ]
}
}

this.toArrayTopLevel = '(Runtime) input.lvl0 must be an object for input to convert to array';
this.toArrayIncompatible = '(Runtime) input.lvl0.test must be an object for input.lvl0 to convert to array'


/////////////////////////////////////////// $scope //////////////////////////////////////////////////

this.scopeAllLevel = {
  a: {
    'scope-A': { Level: 'a', x: 5 },
    data: {
      b: {
        'scope-B': { Level: 'b', x: 5, y: 10 },
        data: {
          c: {
            'scope-C': { Level: 'c', x: 5, y: 10 },
            data: {
              d: {
                'scope-D': { Level: 'd', x: 5, y: 10, z: 15 },
                data: 1
              }
            }
          },
          e: {
            'scope-E': { Level: 'b', x: 5, y: 10, currLevel: 'e' },
            data: {}
          }
        }
      },
      f: {
        'scope-F': {
          Level: 'a',
          x: null,
          currLevel: 'f',
          y: undefined,
          z: '\n'
        },
        data: {}
      }
    }
  },
  g: {
    'scope-G': { Level: 'g', y: 50 },
    data: {
      h: { 'scope-H': { Level: 'g', y: 55, currLevel: 'h' }, data: 2 }
    }
  }
}

this.scopeString = '(Compile) one of\nfilter.a.$scope must be of type Function (not String) or\nfilter.a.$scope must be of type Object (not String)'
this.scopeFn = '(Runtime) input.a.$scope function must return a value of type Object'
this.scopeNumber = '(Compile) one of\nfilter.a.$scope must be of type Function (not Number) or\nfilter.a.$scope must be of type Object (not Number)'
this.scopeNull = '(Compile) one of\nfilter.a.$scope must be of type Function (not null) or\nfilter.a.$scope must be of type Object (not null)'

this.scopeUndefined = { a: { b: {} } }



}
module.exports = new outputs();
