const jsxl = require('../lib/jsxl');
const { expect } = require('chai');
const util = require('util');
const { type } = require('os');
const { resolve } = require('path');
const filters = require('./test_data/filters');



var jsxlfunction = function(){

    var errMessage = 'Error: (';


    this.compileAndReturnFilter = async(filters)=>{

       return new Promise((resolve)=>{
        jsxl.compile(
            filters,
            async(err,filter)=>{
                if (err){
                    // console.log(err);
                    resolve([err,err.message])
                }
                resolve(filter);
            },
        );
       }) 
    }

    this.compileAndReturnMultipleFilter = async(filters)=>{

        return new Promise((resolve)=>{
         jsxl.compileMultiple(
             filters,
             async(err,filter)=>{
                 if (err){
                     // console.log(err);
                     resolve([err,err.message])
                 }
                 resolve(filter);
             },
         );
        }) 
     }

     this.addFilters = async(filters)=>{

        return new Promise((resolve)=>{
            jsxl.useFilters(filters)
            console.log('filter added')
        })
     }

    this.execute = async(inputs,filter)=>{

        return new Promise((resolve)=>{
            if(Object.values(filter)[0].toString().includes('Error')){
                resolve(filter);
            }else{
                jsxl.execute(
                    {
                        input:inputs
                    },
                    filter,
                    async(err,output)=>{
                        if(err){
                            // console.log(err)
                            resolve([err,err.message])
                        }
                        // console.log(util.inspect(output,{showHidden: false, depth: null}))
                        // console.log(output)
                        if(output == undefined){
                            resolve(typeof output)
                        }
                        resolve(output)
                    }
                )
            }
        })
    }

    this.jsxlDirect = async(inputs,filter)=>{

        return new Promise((resolve)=>{
            jsxl(
                {
                    input: inputs
                },
                filter,
                async (err, output) => {
                    if(err){
                        // console.log(err)
                        resolve([err,err.message])
                    }
                    // console.log(util.inspect(output,{showHidden: false, depth: null}))
                    // console.log(output)
                    if(output == undefined){
                        resolve(typeof output)
                    }
                    resolve(output)
                }
            );
        })
    }

  this.jsxlExplicitContext = async(target, parameters, inputs, filter)=>{

    return new Promise((resolve)=>{
        jsxl({
            target,
            parameters,
            key: 'input',
            source: {input:inputs}
        },
        filter,
        (err,output)=>{
            if(err){
                resolve(err)
            }
            // console.log(output)
            resolve(target)
        }
        );
    })

  }

 //Use await wherever result variable is called

 this.verifyResult = async(testName,result,error,output)=>{

    describe('',()=>{
        it(testName,async()=>{
            // console.log(util.inspect(Object.values(await result),{showHidden: false, depth: null}))
            if(error == undefined && output){
                try{
                    if(Array.isArray(await output)){
                        expect(JSON.stringify(await result)).to.deep.equal(JSON.stringify(await output))
                    }else{
                        expect(await result).to.be.a(typeof output).and.to.deep.equal(output)
                    }
                }catch(err){
                    if(Object.values(await result)[0] == undefined || !Object.values(await result)[0].toString().includes(errMessage)){
                        console.log("Assertion error ------> "+err.message)
                    }
                    if((await result != undefined || null) && Object.keys(await result).length != 0 && (Object.values(await result)[0] != null||undefined) && Object.values(await result)[0].toString().includes('Error')){
                        throw new Error('Expected to pass but jsxl gave an error  ------> ' + Object.values(await result)[1] );
                    }
                } 
            }
            else 
            if(error){
                try{
                    expect(Object.values(await result)[0]).to.be.a('error')
                    expect(Object.values(await result)[1]).to.deep.equal(error)
                }catch(err){
                    console.log("Assertion error ------> "+err.message)
                    if((Object.values(await result)[0] != null) && !(Object.values(await result)[0].toString().includes('Error'))){
                        throw new Error('Expected to fail but jsxl did not return any error');
                    }
                }
            }
            else{
                throw new Error('Expected errors or output are not defined properly');
            }
        })
    })

   

  }


   
}
module.exports = new jsxlfunction()